<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Generador Canvas Instagram - App Única (Logo Fijo)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&display=swap" rel="stylesheet">
  <!-- Puedes añadir otras fuentes aquí si quieres selector de fuente para el texto adicional -->
  <!-- <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet"> -->

  <style>
    /* Tipografía base */
    body {
      font-family: 'Inter', sans-serif;
      line-height: 1.5;
      background-color: #ffffff; /* Fondo general más suave */
    }
    select, input, button, textarea {
      font-family: inherit;
    }

    /* Canvas */
    /* Clases para previsualización (las dimensiones reales son mayores) */
    canvas.collage-preview,
    canvas.collage-preview-horizontal {
      display: block;
      margin: 0 auto;
      background-color: #ffffff; /* Esto es solo para la previsualización CSS */
      border: 1px solid #e5e7eb;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      max-width: 100%; /* Asegura que no exceda el contenedor */
      /* Ajusta el tamaño de previsualización */
      width: 180px; /* O el que prefieras para la vista */
      height: auto; /* Mantener la proporción */
    }

    /* Input File (ocultamos el input real) */
    input[type="file"] {
      display: none;
    }


    /* Range */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px;
      background: #d1d5db;
      border-radius: 5px;
      outline: none;
      opacity: .7;
      transition: opacity .2s;
      cursor: pointer;
    }
    input[type="range"]:hover {
      opacity: 1;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #000; /* Thumb color */
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #000; /* Thumb color */
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }


    /* Mensaje (error/éxito/info) */
    #errorMessage {
      display: none; /* Se muestra/oculta con JS */
      margin-bottom: 1.5rem;
      padding: .75rem 1rem;
      border-radius: .375rem;
      text-align: center;
      font-size: .875rem;
    }
    #errorMessage.error {
        color: #b91c1c; /* Red 700 */
        border: 1px solid #fca5a5; /* Red 300 */
        background-color: #fee2e2; /* Red 100 */
    }
    #errorMessage.success {
        color: #047857; /* Green 700 */
        border: 1px solid #a7f3d0; /* Green 300 */
        background-color: #d1fae5; /* Green 100 */
    }
    #errorMessage.info { /* Nuevo estilo para mensajes informativos */
        color: #1e40af; /* Blue 700 */
        border: 1px solid #93c5fd; /* Blue 300 */
        background-color: #eff6ff; /* Blue 100 */
    }


    /* Collage Container */
    .collage-container {
      background-color: white;
      border-radius: 0.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
      padding: 1.5rem; /* Aumentado el padding */
      margin-bottom: 1.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem; /* Espacio entre elementos dentro del contenedor */
    }

    /* Ajuste para tamaños de pantalla más grandes */
    @media (min-width: 768px) {
      .collage-container {
        flex-direction: column;
        align-items: center;
      }
       canvas.collage-preview,
       canvas.collage-preview-horizontal {
         width: 200px; /* Un poco más grande en desktop */
       }
    }

    /* Estilo para el label/botón de subida de archivo */
    .file-upload-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background-color: #000;
        color: white;
        font-weight: 500;
        padding: 0.625rem 1rem; /* py-2.5 px-4 */
        border-radius: 0.375rem; /* rounded-md */
        cursor: pointer;
        transition: background-color 150ms ease-in-out;
        width: 100%; /* Ocupa todo el ancho del contenedor */
        border: none; /* Eliminar borde por defecto */
    }
    .file-upload-button:hover {
        background-color: #1f2937; /* gray-800 */
    }
    .file-upload-button svg {
        margin-right: 0.5rem; /* mr-2 */
        height: 1.25rem; /* h-5 */
        width: 1.25rem; /* w-5 */
        margin-top: -0.125rem; /* -mt-1 */
    }
    /* Estado deshabilitado para el botón de generación */
    #generateBtn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

     /* Estilo para el contenedor de opciones de texto que se muestra/oculta */
    #textOptionsControls {
        display: none; /* Inicialmente oculto */
    }


  </style>
</head>
<body class="text-gray-800 antialiased pb-8">
  <div class="container mx-auto p-4 md:p-8 max-w-5xl">
    <header class="text-center mb-8">
      <h1 class="text-2xl md:text-3xl font-light text-gray-700 uppercase tracking-wider mb-2">Generador Canvas Instagram</h1>
      <p class="text-gray-500 text-sm md:text-base">Crea fácilmente imágenes y collages para tus redes sociales.</p>
    </header>

    <!-- Mensaje de error/éxito/info. Se muestra con JS. -->
    <div id="errorMessage" class="hidden"></div>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
      <!-- PANEL IZQUIERDO -->
      <div class="space-y-6">

        <!-- Plantilla e Imágenes -->
        <section class="bg-white p-5 rounded-lg shadow">
          <h3 class="text-lg font-semibold text-gray-700 mb-4 border-b pb-2">1. Plantilla e Imágenes</h3>
          <div class="form-group mb-4">
            <label for="template" class="block text-sm font-medium text-gray-600 mb-2">Plantilla:</label>
            <select id="template" class="w-full p-2 border border-gray-300 rounded-md focus:ring-gray-900 focus:border-gray-900 text-sm">
              <!-- Grupo para Historias (1080x1920) -->
              <optgroup label="HISTORIAS (1080x1920)">
                <option value="1-single-1920">1 imagen (1080x1920)</option>
                <option value="2-horizontal-1920">2 imágenes horizontal (1080x1920)</option>
                <option value="3-horizontal-1920">3 imágenes horizontal (1080x1920)</option>
                <option value="4-2x2-1920">4 imágenes 2x2 (1080x1920)</option>
                <option value="9-3x3-1920">9 imágenes 3x3 (1080x1920)</option>
                <option value="12-3x4-1920">12 imágenes 3x4 (1080x1920)</option>
              </optgroup>

              <!-- Grupo para Publicaciones (1080x1350) -->
              <optgroup label="PUBLICACIONES (1080x1350)">
                <option value="1-single-1350">1 imagen (1080x1350)</option>
                <option value="2-horizontal-1350">2 imágenes horizontal (1080x1350)</option>
                <option value="3-horizontal-1350">3 imágenes horizontal (1080x1350)</option>
                <option value="4-2x2-1350">4 imágenes 2x2 (1080x1350)</option>
                <option value="9-3x3-1350">9 imágenes 3x3 (1080x1350)</option>
              </optgroup>
            </select>
          </div>

          <div>
            <label for="imageInput" class="file-upload-button mb-2">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd" />
              </svg>
              Seleccionar Imágenes
            </label>
            <input type="file" id="imageInput" multiple accept="image/*">
            <div id="fileInfo" class="text-xs text-gray-500 truncate text-left">Ningún archivo seleccionado.</div>
          </div>
        </section>

        <!-- Opciones de Diseño -->
        <section class="bg-white p-5 rounded-lg shadow">
           <h3 class="text-lg font-semibold text-gray-700 mb-4 border-b pb-2">2. Opciones de Diseño</h3>
           <div class="space-y-4">
               <div>
                   <label for="backgroundColor" class="block text-sm font-medium text-gray-600 mb-1">Color de fondo:</label>
                   <input type="color" id="backgroundColor" value="#ffffff" class="w-full h-10 p-1 border border-gray-300 rounded-md cursor-pointer">
               </div>
               <div>
                   <label for="imageMargin" class="block text-sm font-medium text-gray-600 mb-2">Margen entre imágenes:</label>
                   <input type="range" id="imageMargin" min="0" max="50" value="0">
                   <div id="imageMarginValue" class="text-xs text-gray-500 text-right mt-1">Valor: 0 px</div>
               </div>
           </div>
        </section>

        <!-- Texto Adicional (NUEVA SECCIÓN) -->
         <section class="bg-white p-5 rounded-lg shadow">
             <h3 class="text-lg font-semibold text-gray-700 mb-4 border-b pb-2">3. Texto Adicional</h3>
             <div class="space-y-4">
                 <div class="flex items-center">
                     <input id="addAdditionalText" type="checkbox" class="h-4 w-4 text-gray-900 border-gray-300 rounded focus:ring-gray-900">
                     <label for="addAdditionalText" class="ml-2 block text-sm text-gray-700">Añadir texto adicional al canvas</label>
                 </div>

                 <!-- Controles de Texto Adicional (Mostrado/Oculto por JS) -->
                 <div id="textOptionsControls" class="space-y-4 border-t pt-4 mt-4">
                     <div>
                         <label for="additionalTextInput" class="block text-sm font-medium text-gray-600 mb-1">Texto:</label>
                         <input type="text" id="additionalTextInput" placeholder="Escribe tu texto aquí..." class="w-full p-2 border border-gray-300 rounded-md text-sm">
                     </div>
                     <div>
                       <label for="additionalTextFontSize" class="block text-sm font-medium text-gray-600 mb-1">
                         Tamaño del texto: <span id="additionalTextFontSizeValue" class="font-semibold text-gray-900">40</span>px
                       </label>
                       <input type="range" id="additionalTextFontSize" min="15" max="100" value="40"
                              class="w-full h-2 bg-gray-200 rounded-lg cursor-pointer">
                     </div>
                     <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                       <div>
                           <label for="additionalTextColorSelect" class="block text-sm font-medium text-gray-600 mb-1">
                             Color Texto:
                           </label>
                           <select id="additionalTextColorSelect" class="w-full p-2 border border-gray-300 rounded-md text-sm">
                             <option value="#000000" selected>Negro</option>
                             <option value="#FFFFFF">Blanco</option>
                             <option value="#666666">Gris Medio</option>
                             <option value="#FF0000">Rojo</option>
                             <option value="#0000FF">Azul</option>
                             <option value="#008000">Verde</option>
                             <option value="#FFA500">Naranja</option>
                             <option value="#800080">Púrpura</option>
                             <option value="#FFC0CB">Rosa</option>
                              <!-- Puedes añadir más colores si lo deseas -->
                           </select>
                       </div>
                       <div>
                           <label for="additionalTextShadowColorSelect" class="block text-sm font-medium text-gray-600 mb-1">
                             Color Sombra:
                           </label>
                           <select id="additionalTextShadowColorSelect" class="w-full p-2 border border-gray-300 rounded-md text-sm">
                             <option value="#FFFFFF" selected>Blanco</option>
                             <option value="#000000">Negro</option>
                             <option value="#666666">Gris Medio</option>
                              <option value="transparent">Sin Sombra</option>
                               <!-- Puedes añadir más colores si lo deseas -->
                           </select>
                       </div>
                     </div>
                     <div class="flex items-center">
                         <input id="enableAdditionalTextShadow" type="checkbox" checked class="h-4 w-4 text-gray-900 border-gray-300 rounded focus:ring-gray-900">
                         <label for="enableAdditionalTextShadow" class="ml-2 block text-sm text-gray-700">Activar sombra en el texto</label>
                     </div>
                 </div> <!-- Fin textOptionsControls -->
             </div>
         </section>


        <!-- Opciones de logo -->
        <section class="bg-white p-5 rounded-lg shadow">
          <h3 class="text-lg font-semibold text-gray-700 mb-4 border-b pb-2">4. Opciones de Logo</h3> <!-- Cambiado a paso 4 -->
          <div class="space-y-4">
             <!-- Opción para añadir logo (solo el predefinido) -->
             <div class="flex items-center">
                <input id="addLogo" type="checkbox" class="h-4 w-4 text-gray-900 border-gray-300 rounded focus:ring-gray-900">
                <label for="addLogo" class="ml-2 block text-sm text-gray-700">Añadir logo predefinido al canvas</label>
             </div>

             <!-- Opciones de control del logo -->
             <!-- Este div se muestra/oculta con JS dependiendo del checkbox "Añadir logo" -->
             <div id="logoOptionsControls" class="space-y-4 border-t pt-4 mt-4">
                <div class="flex items-center">
                  <input id="invertLogo" type="checkbox" class="h-4 w-4 text-gray-900 border-gray-300 rounded focus:ring-gray-900">
                  <label for="invertLogo" class="ml-2 block text-sm text-gray-700">Invertir colores del logo</label>
                </div>

                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label for="logoPosition" class="block text-sm font-medium text-gray-600 mb-1">Posición del logo:</label>
                    <select id="logoPosition" class="w-full p-2 border border-gray-300 rounded-md focus:ring-gray-900 focus:border-gray-900 text-sm">
                      <option value="bottomRight">Esquina inferior derecha</option>
                      <option value="center">Centro</option>
                      <option value="bottomLeft">Esquina inferior izquierda</option>
                       <option value="topRight">Esquina superior derecha</option>
                       <option value="topLeft">Esquina superior izquierda</option>
                    </select>
                  </div>
                  <div>
                    <label for="logoSize" class="block text-sm font-medium text-gray-600 mb-1">Tamaño del logo:</label>
                    <select id="logoSize" class="w-full p-2 border border-gray-300 rounded-md focus:ring-gray-900 focus:border-gray-900 text-sm">
                      <option value="8">Muy pequeño (8%)</option>
                      <option value="15">Pequeño (15%)</option>
                      <option value="25" selected>Normal (25%)</option>
                      <option value="35">Grande (35%)</option>
                    </select>
                  </div>
                </div>
             </div> <!-- Fin logoOptionsControls -->
          </div>
        </section>

        <!-- Efectos -->
        <section class="bg-white p-5 rounded-lg shadow">
          <h3 class="text-lg font-semibold text-gray-700 mb-4 border-b pb-2">5. Efectos</h3> <!-- Cambiado a paso 5 -->
          <div class="space-y-2 pt-2">
            <div class="flex items-center">
              <input id="applyBW" type="checkbox" class="h-4 w-4 text-gray-900 border-gray-300 rounded focus:ring-gray-900">
              <label for="applyBW" class="ml-2 block text-sm text-gray-700">Aplicar filtro blanco y negro a todas las imágenes</label>
            </div>
             <!-- Se pueden añadir más efectos aquí -->
          </div>
        </section>
      </div>

      <!-- PANEL DERECHO -->
      <div class="space-y-6">
        <!-- Sección de Acciones -->
        <section class="bg-white p-5 rounded-lg shadow md:sticky md:top-8">
          <h3 class="text-lg font-semibold text-gray-700 mb-4 border-b pb-2">Acciones y Vista Previa</h3>

          <p class="text-sm text-gray-500 mb-4">Configura las opciones en el panel izquierdo y haz clic en "Generar Canvas" para ver el resultado.</p>

          <div class="action-buttons mt-6 flex flex-col sm:flex-row justify-center gap-3">
            <button id="generateBtn" onclick="processAndDisplayCollages()" class="inline-flex items-center justify-center px-5 py-2.5 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-gray-800 hover:bg-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-900 transition duration-150 ease-in-out">
              <svg xmlns="http://www.w3.org/2000/svg" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" id="generate-spinner" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l2-2.647z"></path></svg>
              <span id="generate-text">Generar Canvas</span>
            </button>
            <button onclick="resetCollages()" class="inline-flex items-center justify-center px-5 py-2.5 border border-gray-300 text-base font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-900 transition duration-150 ease-in-out">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 110 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
              </svg>
              Reiniciar Canvas
            </button>
          </div>

           <div id="canvasContainer" class="grid grid-cols-1 md:grid-cols-1 lg:grid-cols-1 gap-6 mt-6">
             <!-- Los canvas generados se insertarán aquí -->
              <p class="text-sm text-gray-500 text-center">Los canvas generados aparecerán aquí.</p>
           </div>
        </section>
      </div>
    </div>

  </div>

  <script>
    // URL del logo predefinido (¡Este es el único logo que se usará!)
    const FIXED_LOGO_URL = 'https://static.wixstatic.com/media/5dbf30_64f6bb0f2f814941a9f344882afbf4e8~mv2.png';
    let preloadedFixedLogo = null; // Variable para almacenar el logo fijo pre-cargado


    // Estado central de la aplicación (simplificado)
    const appState = {
        files: null,
        template: '1-single-1920', // Default template
        backgroundColor: '#ffffff', // Default background color
        imageMargin: 0, // Default margin
        addLogo: false, // Si se debe añadir el logo fijo
        invertLogo: false,
        logoPosition: 'bottomRight',
        logoSizePercent: 25, // Default size
        applyBW: false,
        // --- Estado para Texto Adicional ---
        additionalText: '',
        addAdditionalText: false,
        additionalTextFontSize: 40, // Default font size
        additionalTextColor: '#000000', // Default text color
        additionalTextShadowColor: '#FFFFFF', // Default shadow color (white)
        enableAdditionalTextShadow: true, // Shadow enabled by default
        // --- Fin Estado Texto Adicional ---
    };

    // Referencias a elementos DOM
    const imageInput = document.getElementById('imageInput');
    const fileInfo = document.getElementById('fileInfo');
    const templateSelect = document.getElementById('template');
    const backgroundColorInput = document.getElementById('backgroundColor');
    const imageMarginInput = document.getElementById('imageMargin');
    const imageMarginValueSpan = document.getElementById('imageMarginValue');
    const addLogoCheckbox = document.getElementById('addLogo'); // Checkbox para añadir el logo fijo
    const invertLogoCheckbox = document.getElementById('invertLogo');
    const logoPositionSelect = document.getElementById('logoPosition');
    const logoSizeSelect = document.getElementById('logoSize');
    const applyBWCheckbox = document.getElementById('applyBW');
    const canvasContainer = document.getElementById('canvasContainer');
    const generateBtn = document.getElementById('generateBtn');
    const generateBtnSpinner = document.getElementById('generate-spinner'); // Referencia al spinner
    const generateBtnText = document.getElementById('generate-text');     // Referencia al texto del botón
    const errorMessageDiv = document.getElementById('errorMessage');
    const logoOptionsControlsDiv = document.getElementById('logoOptionsControls'); // El contenedor de las opciones de logo

    // --- Referencias para Texto Adicional ---
    const additionalTextInput = document.getElementById('additionalTextInput');
    const addAdditionalTextCheckbox = document.getElementById('addAdditionalText');
    const additionalTextFontSizeInput = document.getElementById('additionalTextFontSize');
    const additionalTextFontSizeValueSpan = document.getElementById('additionalTextFontSizeValue');
    const additionalTextColorSelect = document.getElementById('additionalTextColorSelect');
    const additionalTextShadowColorSelect = document.getElementById('additionalTextShadowColorSelect');
    const enableAdditionalTextShadowCheckbox = document.getElementById('enableAdditionalTextShadow');
    const textOptionsControlsDiv = document.getElementById('textOptionsControls'); // Contenedor de opciones de texto
    // --- Fin Referencias Texto Adicional ---


    // --- Event Listeners para actualizar el estado ---

    imageInput.addEventListener('change', function() {
        appState.files = this.files;
        if (this.files && this.files.length > 0) {
            fileInfo.textContent = `${this.files.length} archivo(s) seleccionado(s).`;
        } else {
            fileInfo.textContent = 'Ningún archivo seleccionado.';
        }
    });

    // Permitir arrastrar y soltar imágenes
     document.body.addEventListener('dragover', (e) => {
         e.preventDefault(); // Prevent default to allow drop
         e.stopPropagation();
         document.body.classList.add('dragging-over'); // Optional: Add visual cue
     });
     document.body.addEventListener('dragleave', (e) => {
          e.stopPropagation();
          document.body.classList.remove('dragging-over');
     });

     document.body.addEventListener('drop', (e) => {
         e.preventDefault(); // Prevent default action (opening in new tab)
         e.stopPropagation();
         document.body.classList.remove('dragging-over');
         const files = e.dataTransfer.files;
         if (files && files.length > 0) {
             // Use the DataTransfer object directly to assign files
             const dataTransfer = new DataTransfer();
             for (let i = 0; i < files.length; i++) {
                 if (files[i].type.startsWith('image/')) {
                     dataTransfer.items.add(files[i]);
                 } else {
                     console.warn(`Ignorando archivo no imagen: ${files[i].name}`);
                 }
             }
             imageInput.files = dataTransfer.files;
             imageInput.dispatchEvent(new Event('change')); // Trigger change event
         }
     });


    templateSelect.addEventListener('change', function() { appState.template = this.value; });
    backgroundColorInput.addEventListener('input', function() { appState.backgroundColor = this.value; }); // Use input for live update
    imageMarginInput.addEventListener('input', function() { // Use input for live update of range value
        appState.imageMargin = parseInt(this.value);
        imageMarginValueSpan.textContent = `Valor: ${appState.imageMargin} px`;
    });

    // Listener para el checkbox "Añadir logo predefinido"
    addLogoCheckbox.addEventListener('change', function() {
        appState.addLogo = this.checked;
        toggleLogoOptionsControls(this.checked); // Mostrar/ocultar controles al cambiar
    });

    invertLogoCheckbox.addEventListener('change', function() { appState.invertLogo = this.checked; });
    logoPositionSelect.addEventListener('change', function() { appState.logoPosition = this.value; });
    logoSizeSelect.addEventListener('change', function() { appState.logoSizePercent = parseInt(this.value); });
    applyBWCheckbox.addEventListener('change', function() { appState.applyBW = this.checked; });

    // --- Listeners para Texto Adicional ---
    additionalTextInput.addEventListener('input', function() {
        appState.additionalText = this.value;
    });
    addAdditionalTextCheckbox.addEventListener('change', function() {
        appState.addAdditionalText = this.checked;
        toggleTextOptionsControls(this.checked); // Mostrar/ocultar controles al cambiar
    });
     additionalTextFontSizeInput.addEventListener('input', function() {
         appState.additionalTextFontSize = parseInt(this.value);
         additionalTextFontSizeValueSpan.textContent = `${this.value}px`;
     });
    additionalTextColorSelect.addEventListener('change', function() {
        appState.additionalTextColor = this.value;
    });
    additionalTextShadowColorSelect.addEventListener('change', function() {
        appState.additionalTextShadowColor = this.value;
    });
    enableAdditionalTextShadowCheckbox.addEventListener('change', function() {
        appState.enableAdditionalTextShadow = this.checked;
    });
    // --- Fin Listeners Texto Adicional ---


    // --- Funciones de UI/Feedback ---

    // Muestra u oculta los controles dependientes de "Añadir logo"
    function toggleLogoOptionsControls(show) {
        if (logoOptionsControlsDiv) {
            logoOptionsControlsDiv.style.display = show ? 'block' : 'none';
        }
    }

    // Muestra u oculta los controles dependientes de "Añadir texto adicional"
     function toggleTextOptionsControls(show) {
         if (textOptionsControlsDiv) {
             textOptionsControlsDiv.style.display = show ? 'block' : 'none';
         }
     }


    // Función para mostrar mensajes (error, success, info)
    function showMessage(message, type = 'error') {
      const messageEl = errorMessageDiv; // Usa la referencia global
      messageEl.textContent = message;

      // Limpiar clases anteriores y aplicar las nuevas
      messageEl.className = 'mb-4 p-3 rounded-md text-sm'; // Clases base
      messageEl.classList.add(type); // Añade clase 'error', 'success' o 'info'

      messageEl.style.display = 'block';

      // Ocultar el mensaje después de 7 segundos (un poco más)
      setTimeout(() => {
        messageEl.style.display = 'none';
      }, 7000);
    }

    // Funciones de helper
    function showError(message) { showMessage(message, 'error'); }
    function showSuccess(message) { showMessage(message, 'success'); }
    function showInfo(message) { showMessage(message, 'info'); }


    // --- Funciones de Carga de Imágenes ---

    // Función para pre-cargar una imagen desde una URL (¡Solo para el logo fijo!)
    async function preloadLogo(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'Anonymous'; // CRUCIAL si el logo no está en el mismo dominio
            img.onload = () => resolve(img);
            img.onerror = (err) => reject(err);
            img.src = url;
        });
    }

    // Función para cargar múltiples imágenes desde FileList (¡Solo para las imágenes principales!)
    async function loadImages(files) {
         if (!files || files.length === 0) return [];

         showInfo(`Cargando ${files.length} imagen(es)...`);

         const loadedImages = await Promise.all(Array.from(files).map(file => {
             return new Promise(resolve => {
                 if (!file.type.startsWith('image/')) {
                      console.warn(`Skipping non-image file: ${file.name}`);
                      resolve(null); // Resolve with null for non-image files
                      return;
                 }
                 const img = new Image();
                 img.onload = () => resolve(img);
                 img.onerror = (err) => {
                      console.error('Error loading image file:', file.name, err);
                      resolve(null); // Resolve with null for failed loads
                 };
                 // No use URL.createObjectURL here if you load many images, can cause memory issues.
                 // Better to use a FileReader and base64 for limited set or array buffers for many.
                 // For simplicity and likely use case (few images at once), keep URL.createObjectURL but revoke.
                 const reader = new FileReader();
                 reader.onload = (e) => {
                      img.src = e.target.result; // Use base64 data url
                 }
                 reader.onerror = (err) => {
                      console.error('FileReader error loading image:', file.name, err);
                      resolve(null);
                 }
                 reader.readAsDataURL(file); // Read as Base64
             });
         }));

         // Clean up object URLs AFTER processing if createObjectURL was used.
         // Since we switched to DataURL, no revokeObjectURL needed for files themselves.

         const validImages = loadedImages.filter(img => img !== null && img.width > 0 && img.height > 0); // Filter null and invalid images

         if (validImages.length < loadedImages.length) {
              showError(`Se cargaron ${validImages.length} de ${loadedImages.length} imagen(es) válidas. Ignorando archivos no válidos/con errores.`);
         } else if (validImages.length > 0) {
              showSuccess(`Todas las imágenes (${validImages.length}) cargadas correctamente.`);
         }


         return validImages;
    }


    // --- Funciones de Dibujo y Efectos ---

    // Función para dibujar una imagen recortada y ajustada al contenedor
    function drawCroppedImage(ctx, img, x, y, w, h) {
        if (!img || !ctx || w <= 0 || h <= 0) {
             console.warn("drawCroppedImage: Invalid parameters or dimensions.", {img, x,y,w,h});
             // Draw a placeholder if drawing is not possible
             ctx.fillStyle = '#f0f0f0'; ctx.fillRect(x, y, w, h);
             ctx.fillStyle = '#cc3333'; // Color de texto para error
             let fontSize = Math.min(w, h) * 0.1;
             fontSize = Math.max(15, Math.min(fontSize, 40));
             ctx.font = `${fontSize}px Inter, sans-serif`;
             ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
             ctx.fillText('Draw Error', x + w/2, y + h/2);
             return;
        }

        const imgAspect = img.width / img.height;
        const boxAspect = w / h;
        let sx, sy, sWidth, sHeight;

        if (imgAspect > boxAspect) {
            // Imagen es proporcionalmente más ancha que la caja (horizontal o más ancha vertical)
            sHeight = img.height;
            sWidth = img.height * boxAspect;
            sx = (img.width - sWidth) / 2;
            sy = 0;
        } else {
            // Imagen es proporcionalmente más alta que la caja (vertical o más alta horizontal)
            sWidth = img.width;
            sHeight = img.width / boxAspect;
            sx = 0;
            sy = (img.height - sHeight) / 2;
        }

        // Ensure source dimensions are positive and within bounds
         if (sWidth <= 0 || sHeight <= 0 || sx < -1 || sy < -1 || sx + sWidth > img.width + 1 || sy + sHeight > img.height + 1) { // Add small tolerance for float errors
             console.warn("Calculated source dimensions are invalid for cropping.", {imgAspect, boxAspect, imgWidth: img.width, imgHeight: img.height, boxW: w, boxH: h, sx, sy, sWidth, sHeight});
             // Dibujar un placeholder en su lugar si el cálculo falla
             ctx.fillStyle = '#f0f0f0'; ctx.fillRect(x, y, w, h);
             ctx.fillStyle = '#cc3333'; // Color de texto para error
             let fontSize = Math.min(w, h) * 0.1;
             fontSize = Math.max(15, Math.min(fontSize, 40));
             ctx.font = `${fontSize}px Inter, sans-serif`;
             ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
             ctx.fillText('Crop Error', x + w/2, y + h/2);
             return; // Skip drawing the image
        }


        try {
           ctx.drawImage(img, sx, sy, sWidth, sHeight, x, y, w, h);
        } catch (error) {
            console.error("Error drawing image:", error, {img, sx, sy, sWidth, sHeight, x, y, w, h});
             // Dibujar un placeholder en caso de error de dibujo
             ctx.fillStyle = '#f0f0f0'; ctx.fillRect(x, y, w, h);
             ctx.fillStyle = '#cc3333'; // Color de texto para error
             let fontSize = Math.min(w, h) * 0.1;
             fontSize = Math.max(15, Math.min(fontSize, 40));
             ctx.font = `${fontSize}px Inter, sans-serif`;
             ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
             ctx.fillText('Draw Error', x + w/2, y + h/2);
        }
    }

    // Función para invertir colores de una imagen (devuelve un nuevo Image object)
    function invertImageColors(imageElement) {
        if (!imageElement) return null;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = imageElement.width;
        tempCanvas.height = imageElement.height;
        const tempCtx = tempCanvas.getContext('2d');

        // Draw the original image onto the temporary canvas
        tempCtx.drawImage(imageElement, 0, 0);

        // Get the image data
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imageData.data;

        // Invert colors (R, G, B channels)
        for (let i = 0; i < data.length; i += 4) {
            data[i] = 255 - data[i];       // Red
            data[i + 1] = 255 - data[i + 1]; // Green
            data[i + 2] = 255 - data[i + 2]; // Blue
            // Alpha channel (data[i + 3]) is left unchanged
        }

        // Put the modified image data back onto the temporary canvas
        tempCtx.putImageData(imageData, 0, 0);

        // Create a new Image object from the temporary canvas
        const invertedImage = new Image();
        invertedImage.src = tempCanvas.toDataURL(); // Convert canvas content to data URL

        // Note: This returns a new Image object immediately, but its `onload` event
        // needs to fire before it can be drawn. For simple cases like drawing it
        // right after, the drawing might happen before it's fully loaded, resulting
        // in nothing drawn or drawing the previous content. For this app's use case
        // (drawing on a fresh canvas context within a synchronous loop), it might
        // work, but be aware of potential async issues with Image() from DataURL.
        // A more robust approach might involve working directly with ImageData or
        // returning the temporary canvas itself. For now, let's assume drawing the
        // DataURL image works quickly enough in this context.

        return invertedImage;
    }


    // Función para convertir a blanco y negro (aplica al canvas directamente)
    function applyBlackAndWhite(canvas) {
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      // Get the entire canvas content as ImageData
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      // Iterate through each pixel (steps of 4: R, G, B, A)
      for (let i = 0; i < data.length; i += 4) {
        // Calculate grayscale value using Luma method (more accurate perception)
        const avg = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
        // Set R, G, and B channels to the grayscale value
        data[i] = avg;     // Red
        data[i + 1] = avg; // Green
        data[i + 2] = avg; // Blue
        // Alpha channel (data[i + 3]) is unchanged
      }

      // Put the modified image data back onto the canvas
      ctx.putImageData(imageData, 0, 0);
    }


    // --- Lógica de Generación del Canvas ---

    // Crea un único canvas basado en un grupo de imágenes y el estado actual
    function createCollageCanvas(imagesForCanvas, state, canvasIndex = 0) {
        const parts = state.template.split('-'); // e.g., ["12", "3x4", "1920"]
        if (parts.length < 3) {
             console.error("Invalid template format:", state.template);
             return null;
        }
        const numImagesExpected = parseInt(parts[0]);
        const layoutType = parts[1];
        const canvasFormatSize = parseInt(parts[2]); // This is height for vertical, or potentially width/height hint for horizontal (though template names clarify)

        const canvasWidth = 1080;
        const canvasHeight = canvasFormatSize; // 1920 or 1350 based on template

        const margin = state.imageMargin; // Margen en píxeles

        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // Class for CSS preview scaling
        if (canvasHeight === 1920) {
          canvas.classList.add('collage-preview');
        } else { // 1350
          canvas.classList.add('collage-preview-horizontal');
        }

        const ctx = canvas.getContext('2d');

        // 1. Draw background
        ctx.fillStyle = state.backgroundColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);


        // 2. Determine cell dimensions and positions (including margins)
        let cols, rows;
        switch (layoutType) {
            case 'single': cols = 1; rows = 1; break;
            case '2x2': cols = 2; rows = 2; break;
            case '3x3': cols = 3; rows = 3; break;
            case '3x4': cols = 3; rows = 4; break; // New 3x4 layout
            case 'horizontal': // 2-horizontal or 3-horizontal
                 cols = 1; // These are vertically stacked, not horizontal cells
                 rows = numImagesExpected; // Number of images determines number of rows
                 break;
            default: console.error("Unknown layout type:", layoutType); return null;
        }

        // Calculate effective space for images after margins
        const totalHorizontalMargin = margin * (cols + 1);
        const totalVerticalMargin = margin * (rows + 1);

        const imageSpaceWidth = canvasWidth - totalHorizontalMargin;
        const imageSpaceHeight = canvasHeight - totalVerticalMargin;

        const boxW = imageSpaceWidth / cols; // Image box width
        const boxH = imageSpaceHeight / rows; // Image box height

        // Validate calculated box dimensions
        if (boxW <= 0 || boxH <= 0) {
             showError(`Error en el cálculo de la plantilla: El margen (${margin}px) es demasiado grande para el canvas de ${canvasWidth}x${canvasHeight}.`);
             return null; // Indicate generation failed
        }

        // 3. Draw images or placeholders in cells
        for (let i = 0; i < numImagesExpected; i++) { // Iterate over the fixed number of cells required by the template
             const img = i < imagesForCanvas.length ? imagesForCanvas[i] : null; // Get image from the group or null

             // Calculate cell start position (initial margin + (index * (size + margin)))
             const col = i % cols;
             const row = Math.floor(i / cols);

             const x = margin + col * (boxW + margin);
             const y = margin + row * (boxH + margin);

             if (img) {
                 drawCroppedImage(ctx, img, x, y, boxW, boxH);
             } else {
                 // Draw placeholder for empty spots
                 ctx.fillStyle = state.backgroundColor === '#ffffff' ? '#f0f0f0' : adjustBrightness(state.backgroundColor, -20); // Placeholder darker than background
                 ctx.fillRect(x, y, boxW, boxH);
                 ctx.fillStyle = state.backgroundColor === '#ffffff' ? '#999999' : adjustBrightness(state.backgroundColor, -50); // Text darker still
                 let fontSize = Math.min(boxW, boxH) * 0.1;
                 fontSize = Math.max(15, Math.min(fontSize, 40)); // Clamp font size
                 ctx.font = `${fontSize}px Inter, sans-serif`; // Use a fixed font for placeholders
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 // Adjust text position slightly for middle baseline centering
                 ctx.fillText('Imagen faltante', x + boxW/2, y + boxH/2 + fontSize/4); // Added fontSize/4 adjustment
             }
        }

        // 4. Apply Black and White filter if selected
        if (state.applyBW) {
           applyBlackAndWhite(canvas); // Applies filter to all drawn content so far
        }

        // 5. Draw Additional Text (NEW)
        if (state.addAdditionalText && state.additionalText.trim() !== '') {
            const text = state.additionalText.trim();
            const fontSize = state.additionalTextFontSize; // Pixels
            const textColor = state.additionalTextColor;
            const shadowColor = state.additionalTextShadowColor;
            const enableShadow = state.enableAdditionalTextShadow;
            const textPaddingBottom = 30; // Padding from the bottom edge

            ctx.font = `${fontSize}px Inter, sans-serif`; // Use Inter font, or make font selectable later
            ctx.fillStyle = textColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'alphabetic'; // Draw text from the baseline

             // Configure text shadow
            if (enableShadow && shadowColor !== 'transparent') {
                ctx.shadowColor   = shadowColor;
                ctx.shadowBlur    = 8; // Example blur
                ctx.shadowOffsetX = 3; // Example offset
                ctx.shadowOffsetY = 3; // Example offset
            } else {
                ctx.shadowColor = 'transparent'; // Disable shadow
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }

            const textX = canvasWidth / 2; // Center horizontally
            const textY = canvasHeight - textPaddingBottom; // Position from the bottom

            // Need to handle potential multi-line text if input can be long.
            // For simplicity, this version assumes a single line that might get cut off.
            // A more advanced version would wrap text based on canvas width.
            // Let's add basic text wrapping for potentially long input.
            const maxTextWidth = canvasWidth * 0.9; // 90% of canvas width
            const words = text.split(' ');
            let currentLine = '';
            const lines = [];

            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                const testLine = currentLine === '' ? word : currentLine + ' ' + word;
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;

                if (testWidth > maxTextWidth && i > 0) { // If test line is too wide, but only if it's not the first word
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine); // Push the last line

            const lineHeight = fontSize * 1.3; // Simple line height based on font size
            const totalTextHeight = lines.length * lineHeight; // Total height block of text
            let startTextY = canvasHeight - textPaddingBottom - totalTextHeight + fontSize; // Calculate starting Y for the first line baseline


            lines.forEach((line, index) => {
                 ctx.fillText(line, textX, startTextY + index * lineHeight);
            });


            // Reset shadow and fillStyle so they don't affect subsequent drawings (like the logo)
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            // ctx.fillStyle doesn't need explicit reset unless the logo was text, which it's not.
        }


        // 6. Add the fixed logo if enabled and loaded (Draws AFTER text)
        if (state.addLogo) {
            let logoToDraw = preloadedFixedLogo; // Always use the preloaded fixed logo

            if (logoToDraw && logoToDraw.width > 0 && logoToDraw.height > 0) {
                 // Apply inversion BEFORE drawing if selected
                 if (state.invertLogo) {
                     // invertImageColors returns a NEW temporary inverted image
                     // This can be slightly slow or cause rendering issues if the new image isn't ready immediately.
                     // A better approach for performance might be to invert the logo *once* when `invertLogo` changes
                     // and store *both* original and inverted versions preloaded.
                      try {
                         logoToDraw = invertImageColors(logoToDraw); // Use the function to get the potentially inverted version
                      } catch(e) {
                         console.error("Failed to invert logo:", e);
                         logoToDraw = preloadedFixedLogo; // Fallback to original if invert fails
                         showInfo("Advertencia: Falló la inversión del logo.");
                      }
                 }

                const logoWidth = (canvas.width * state.logoSizePercent) / 100;
                // Calculate height to maintain aspect ratio
                const logoHeight = (logoToDraw.height * logoWidth) / logoToDraw.width;

                if (logoHeight > 0) {
                    const logoMargin = canvasWidth * 0.03; // Proportional margin (e.g., 3% of width)
                    let logoX, logoY;

                    switch (state.logoPosition) {
                        case 'bottomRight':
                            logoX = canvas.width - logoWidth - logoMargin;
                            logoY = canvas.height - logoHeight - logoMargin;
                            break;
                        case 'bottomLeft':
                            logoX = logoMargin;
                            logoY = canvas.height - logoHeight - logoMargin;
                            break;
                         case 'topRight':
                            logoX = canvas.width - logoWidth - logoMargin;
                            logoY = logoMargin;
                            break;
                         case 'topLeft':
                            logoX = logoMargin;
                            logoY = logoMargin;
                            break;
                        case 'center':
                        default:
                            logoX = (canvas.width - logoWidth) / 2;
                            logoY = (canvas.height - logoHeight) / 2;
                            break;
                    }

                    // Ensure logo is drawn within canvas boundaries
                     logoX = Math.max(0, Math.min(logoX, canvas.width - logoWidth));
                     logoY = Math.max(0, Math.min(logoY, canvas.height - logoHeight));


                    // Draw the logo image
                    ctx.drawImage(logoToDraw, logoX, logoY, logoWidth, logoHeight);

                } else {
                     console.warn("Fixed logo height is zero or invalid after calculation, skipping logo drawing.");
                     showInfo("Advertencia: No se añadió el logo predefinido (problema de tamaño).");
                }
            } else {
                 console.warn("Fixed logo not loaded or dimensions invalid, skipping logo drawing.");
                 showInfo("Advertencia: No se añadió el logo predefinido porque no se pudo cargar o es inválido.");
            }
        }


        // Create the container for this specific canvas
        const collageContainer = document.createElement('div');
        collageContainer.className = 'collage-container';

        // Add simplified info about the canvas type
        const infoSpan = document.createElement('p');
        const selectedOption = templateSelect.querySelector(`option[value="${state.template}"]`);
        const templateDesc = selectedOption ? selectedOption.textContent.split('(')[0].trim() : 'Plantilla desconocida';
        const formatType = canvasHeight === 1920 ? 'HISTORIAS' : 'PUBLICACIONES';
        infoSpan.textContent = `${templateDesc} - ${formatType}`;
        infoSpan.className = 'text-sm text-gray-500 mb-2 text-center w-full';

        collageContainer.appendChild(infoSpan);
        collageContainer.appendChild(canvas);

        // Action buttons (Download, Delete)
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'flex flex-col sm:flex-row justify-center gap-3 w-full'; // w-full to take full width

        // Create download button
        const downloadBtn = document.createElement('a');
        downloadBtn.className = 'inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-gray-800 hover:bg-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-900 transition duration-150 ease-in-out';
        downloadBtn.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
          </svg>
          Descargar Canvas ${canvasIndex + 1}
        `;
        downloadBtn.href = '#';
        downloadBtn.onclick = function(e) {
          e.preventDefault();
          // Get the canvas element to download
          const canvasToDownload = this.closest('.collage-container').querySelector('canvas');
          if (canvasToDownload) {
             const link = document.createElement('a');
             const typeLabel = canvasToDownload.height === 1920 ? 'historia' : 'publicacion';
             link.download = `canvas_${typeLabel}_${canvasIndex + 1}.jpg`;
             link.href = canvasToDownload.toDataURL('image/jpeg', 0.95); // High quality JPEG
             document.body.appendChild(link); // Append to body needed for Firefox
             link.click();
             document.body.removeChild(link); // Clean up
          } else {
             console.error("Canvas element not found for download.");
             showError("Error: No se encontró el canvas para descargar.");
          }
        };

        // Create delete button for this specific canvas
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'inline-flex items-center justify-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-900 transition duration-150 ease-in-out';
        deleteBtn.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-red-500" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553l-.724 1.447H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
          </svg>
          Eliminar
        `;
        deleteBtn.onclick = function() {
          if (confirm('¿Estás seguro que deseas eliminar este canvas?')) {
            collageContainer.remove(); // Remove the whole container div
            // If no canvas containers are left, show the placeholder text
            if(canvasContainer.childElementCount === 0) {
                canvasContainer.innerHTML = '<p class="text-sm text-gray-500 text-center">Los canvas generados aparecerán aquí.</p>';
            }
             showInfo(`Canvas ${canvasIndex + 1} eliminado.`);
          }
        };

        buttonContainer.appendChild(downloadBtn);
        buttonContainer.appendChild(deleteBtn);

        collageContainer.appendChild(buttonContainer);

        return collageContainer; // Return the container div with canvas and buttons
    }

    // Function to adjust hex color brightness (for placeholders)
    function adjustBrightness(hex, percent) {
        // Remove # if exists
        hex = hex.replace(/^#/, '');

        // Convert hex to RGB
        let r = parseInt(hex.substring(0, 2), 16);
        let g = parseInt(hex.substring(2, 4), 16);
        let b = parseInt(hex.substring(4, 6), 16);

        // Adjust brightness
        r = Math.floor(r * (100 + percent) / 100);
        g = Math.floor(g * (100 + percent) / 100);
        b = Math.floor(b * (100 + percent) / 100);

        // Ensure values are between 0 and 255
        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        b = Math.max(0, Math.min(255, b));

        // Convert RGB back to hex
        const toHex = (c) => c.toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }


    // Main function to process and display collages
    async function processAndDisplayCollages() {
      // Disable button and show spinner
      generateBtn.disabled = true;
      generateBtnSpinner.classList.remove('hidden');
      generateBtnText.textContent = 'Generando...';
      errorMessageDiv.style.display = 'none'; // Hide previous messages

      // Validate that images are selected
      if (!appState.files || appState.files.length === 0) {
        showError('Por favor, selecciona al menos una imagen principal.');
        generateBtn.disabled = false;
        generateBtnSpinner.classList.add('hidden');
        generateBtnText.textContent = 'Generar Canvas';
        return;
      }

       // Load the main images asynchronously
      const validImages = await loadImages(appState.files);

      if (validImages.length === 0) {
           showError('No se pudo cargar ninguna de las imágenes seleccionadas. Asegúrate de que son archivos de imagen válidos.');
           generateBtn.disabled = false;
           generateBtnSpinner.classList.add('hidden');
           generateBtnText.textContent = 'Generar Canvas';
           return;
      }

      // Analyze the template value
      const parts = appState.template.split('-');
      if (parts.length < 3) {
          showError('Plantilla seleccionada inválida.');
          generateBtn.disabled = false;
          generateBtnSpinner.classList.add('hidden');
          generateBtnText.textContent = 'Generar Canvas';
          return;
      }
      const numImagesExpected = parseInt(parts[0]);
      const layoutType = parts[1];
      const canvasFormatSize = parseInt(parts[2]);

      // Check if there are enough images for at least one canvas
      if (validImages.length < (layoutType === 'single' ? 1 : numImagesExpected)) {
           showError(`Para la plantilla "${appState.template}", necesitas al menos ${numImagesExpected} imágenes. Solo cargaste ${validImages.length}.`);
           generateBtn.disabled = false;
           generateBtnSpinner.classList.add('hidden');
           generateBtnText.textContent = 'Generar Canvas';
           return;
      }


      // Divide valid images into groups based on the number expected per template
       const groups = [];
       // Special case for single image template: each image gets its own canvas
       if (layoutType === 'single') {
           validImages.forEach(img => groups.push([img]));
       } else {
            // For multi-image templates, group images
           for (let i = 0; i < validImages.length; i += numImagesExpected) {
             groups.push(validImages.slice(i, i + numImagesExpected));
           }
       }


      if (groups.length === 0) {
           showError('No se pudieron formar grupos de imágenes con la plantilla seleccionada. Asegúrate de tener suficientes imágenes.');
           generateBtn.disabled = false;
           generateBtnSpinner.classList.add('hidden');
           generateBtnText.textContent = 'Generar Canvas';
           return;
       }


      // Clear previous canvas containers and the placeholder
      canvasContainer.innerHTML = '';

      // Generate and display each canvas
      groups.forEach((group, index) => {
         // Pass the pre-loaded fixed logo to the canvas creation function
         const collageElement = createCollageCanvas(group, appState, index);
         if(collageElement) {
             canvasContainer.appendChild(collageElement);
         }
      });

      showSuccess(`Se han generado ${groups.length} canvas(es).`);

      // Re-enable button and hide spinner
      generateBtn.disabled = false;
      generateBtnSpinner.classList.add('hidden');
      generateBtnText.textContent = 'Generar Canvas';

      // Optional: Clear the file input after generation if you want users to re-select
      // imageInput.value = '';
      // fileInfo.textContent = 'Ningún archivo seleccionado.';
    }

    // Function to reset/clear all generated canvas elements
    function resetCollages() {
      if (confirm('¿Estás seguro que deseas eliminar todos los canvas generados?')) {
        canvasContainer.innerHTML = '<p class="text-sm text-gray-500 text-center">Los canvas generados aparecerán aquí.</p>'; // Put the placeholder back
        // Also reset relevant state variables if needed, though generating again will overwrite them.
         showInfo('Canvas limpiados.');
      }
    }

    // --- Initial Setup on Load ---
    document.addEventListener('DOMContentLoaded', () => {
         // Set initial state for logo & text options visibility based on checkbox state
         toggleLogoOptionsControls(addLogoCheckbox.checked);
         toggleTextOptionsControls(addAdditionalTextCheckbox.checked);

         // Set initial range value text for margin and font size
         imageMarginValueSpan.textContent = `Valor: ${appState.imageMargin} px`;
         additionalTextFontSizeValueSpan.textContent = `${appState.additionalTextFontSize}px`;

         // Preload the fixed logo immediately on page load
         showInfo('Cargando logo predefinido...');
         preloadLogo(FIXED_LOGO_URL).then(img => {
             preloadedFixedLogo = img;
             console.log('Logo pre-cargado.');
             // showSuccess('Logo predefinido cargado correctamente.'); // Avoid showing success too early, might be covered by other messages
         }).catch(error => {
             console.error('Fallo la pre-carga del logo fijo:', error);
             showError('Advertencia: No se pudo cargar el logo predefinido. La función de logo podría no funcionar.', 'info'); // Gentle error message
         });
    });


  </script>
</body>
</html>