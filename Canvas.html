<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Generador Canvas Instagram - App Única (Logo Fijo)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    /* Tipografía base */
    body {
      font-family: 'Inter', sans-serif;
      line-height: 1.5;
      background-color: #ffffff; /* Fondo general más suave */
    }
    select, input, button, textarea {
      font-family: inherit;
    }

    /* Canvas */
    /* Clases para previsualización (las dimensiones reales son mayores) */
    canvas.collage-preview,
    canvas.collage-preview-horizontal {
      display: block;
      margin: 0 auto;
      background-color: #ffffff; /* Esto es solo para la previsualización CSS */
      border: 1px solid #e5e7eb;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      max-width: 100%; /* Asegura que no exceda el contenedor */
      /* Ajusta el tamaño de previsualización */
      width: 180px; /* O el que prefieras para la vista */
      height: auto; /* Mantener la proporción */
    }

    /* Input File (ocultamos el input real) */
    input[type="file"] {
      display: none;
    }


    /* Range */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px;
      background: #d1d5db;
      border-radius: 5px;
      outline: none;
      opacity: .7;
      transition: opacity .2s;
      cursor: pointer;
    }
    input[type="range"]:hover {
      opacity: 1;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #000; /* Thumb color */
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #000; /* Thumb color */
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }


    /* Mensaje (error/éxito/info) */
    #errorMessage {
      display: none; /* Se muestra/oculta con JS */
      margin-bottom: 1.5rem;
      padding: .75rem 1rem;
      border-radius: .375rem;
      text-align: center;
      font-size: .875rem;
    }
    #errorMessage.error {
        color: #b91c1c; /* Red 700 */
        border: 1px solid #fca5a5; /* Red 300 */
        background-color: #fee2e2; /* Red 100 */
    }
    #errorMessage.success {
        color: #047857; /* Green 700 */
        border: 1px solid #a7f3d0; /* Green 300 */
        background-color: #d1fae5; /* Green 100 */
    }
    #errorMessage.info { /* Nuevo estilo para mensajes informativos */
        color: #1e40af; /* Blue 700 */
        border: 1px solid #93c5fd; /* Blue 300 */
        background-color: #eff6ff; /* Blue 100 */
    }


    /* Collage Container */
    .collage-container {
      background-color: white;
      border-radius: 0.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
      padding: 1.5rem; /* Aumentado el padding */
      margin-bottom: 1.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem; /* Espacio entre elementos dentro del contenedor */
    }

    /* Ajuste para tamaños de pantalla más grandes */
    @media (min-width: 768px) {
      .collage-container {
        flex-direction: column;
        align-items: center;
      }
       canvas.collage-preview,
       canvas.collage-preview-horizontal {
         width: 200px; /* Un poco más grande en desktop */
       }
    }

    /* Estilo para el label/botón de subida de archivo */
    .file-upload-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background-color: #000;
        color: white;
        font-weight: 500;
        padding: 0.625rem 1rem; /* py-2.5 px-4 */
        border-radius: 0.375rem; /* rounded-md */
        cursor: pointer;
        transition: background-color 150ms ease-in-out;
        width: 100%; /* Ocupa todo el ancho del contenedor */
        border: none; /* Eliminar borde por defecto */
    }
    .file-upload-button:hover {
        background-color: #1f2937; /* gray-800 */
    }
    .file-upload-button svg {
        margin-right: 0.5rem; /* mr-2 */
        height: 1.25rem; /* h-5 */
        width: 1.25rem; /* w-5 */
        margin-top: -0.125rem; /* -mt-1 */
    }
    /* Estado deshabilitado para el botón de generación */
    #generateBtn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }


  </style>
</head>
<body class="text-gray-800 antialiased pb-8">
  <div class="container mx-auto p-4 md:p-8 max-w-5xl">
    <header class="text-center mb-8">
      <h1 class="text-2xl md:text-3xl font-light text-gray-700 uppercase tracking-wider mb-2">Generador Canvas Instagram</h1>
      <p class="text-gray-500 text-sm md:text-base">Crea fácilmente imágenes y collages para tus redes sociales.</p>
    </header>

    <!-- Mensaje de error/éxito/info. Se muestra con JS. -->
    <div id="errorMessage" class="hidden"></div>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
      <!-- PANEL IZQUIERDO -->
      <div class="space-y-6">

        <!-- Plantilla e Imágenes -->
        <section class="bg-white p-5 rounded-lg shadow">
          <h3 class="text-lg font-semibold text-gray-700 mb-4 border-b pb-2">1. Plantilla e Imágenes</h3>
          <div class="form-group mb-4">
            <label for="template" class="block text-sm font-medium text-gray-600 mb-2">Plantilla:</label>
            <select id="template" class="w-full p-2 border border-gray-300 rounded-md focus:ring-gray-900 focus:border-gray-900 text-sm">
              <!-- Grupo para Historias (1080x1920) -->
              <optgroup label="HISTORIAS (1080x1920)">
                <option value="1-single-1920">1 imagen (1080x1920)</option>
                <option value="2-horizontal-1920">2 imágenes horizontal (1080x1920)</option>
                <option value="3-horizontal-1920">3 imágenes horizontal (1080x1920)</option>
                <option value="4-2x2-1920">4 imágenes 2x2 (1080x1920)</option>
                <option value="9-3x3-1920">9 imágenes 3x3 (1080x1920)</option>
                <option value="12-3x4-1920">12 imágenes 3x4 (1080x1920)</option>
              </optgroup>

              <!-- Grupo para Publicaciones (1080x1350) -->
              <optgroup label="PUBLICACIONES (1080x1350)">
                <option value="1-single-1350">1 imagen (1080x1350)</option>
                <option value="2-horizontal-1350">2 imágenes horizontal (1080x1350)</option>
                <option value="3-horizontal-1350">3 imágenes horizontal (1080x1350)</option>
                <option value="4-2x2-1350">4 imágenes 2x2 (1080x1350)</option>
                <option value="9-3x3-1350">9 imágenes 3x3 (1080x1350)</option>
              </optgroup>
            </select>
          </div>

          <div>
            <label for="imageInput" class="file-upload-button mb-2">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd" />
              </svg>
              Seleccionar Imágenes
            </label>
            <input type="file" id="imageInput" multiple accept="image/*">
            <div id="fileInfo" class="text-xs text-gray-500 truncate text-left">Ningún archivo seleccionado.</div>
          </div>
        </section>

        <!-- Opciones de Diseño -->
        <section class="bg-white p-5 rounded-lg shadow">
           <h3 class="text-lg font-semibold text-gray-700 mb-4 border-b pb-2">2. Opciones de Diseño</h3>
           <div class="space-y-4">
               <div>
                   <label for="backgroundColor" class="block text-sm font-medium text-gray-600 mb-1">Color de fondo:</label>
                   <input type="color" id="backgroundColor" value="#ffffff" class="w-full h-10 p-1 border border-gray-300 rounded-md cursor-pointer">
               </div>
               <div>
                   <label for="imageMargin" class="block text-sm font-medium text-gray-600 mb-2">Margen entre imágenes:</label>
                   <input type="range" id="imageMargin" min="0" max="50" value="0">
                   <div id="imageMarginValue" class="text-xs text-gray-500 text-right mt-1">Valor: 0 px</div>
               </div>
           </div>
        </section>

        <!-- Opciones de logo -->
        <section class="bg-white p-5 rounded-lg shadow">
          <h3 class="text-lg font-semibold text-gray-700 mb-4 border-b pb-2">3. Opciones de Logo</h3>
          <div class="space-y-4">
             <!-- Opción para añadir logo (solo el predefinido) -->
             <div class="flex items-center">
                <input id="addLogo" type="checkbox" class="h-4 w-4 text-gray-900 border-gray-300 rounded focus:ring-gray-900">
                <label for="addLogo" class="ml-2 block text-sm text-gray-700">Añadir logo predefinido al canvas</label>
             </div>

             <!-- Opciones de control del logo -->
             <!-- Este div se muestra/oculta con JS dependiendo del checkbox "Añadir logo" -->
             <div id="logoOptionsControls" class="space-y-4 border-t pt-4 mt-4">
                <div class="flex items-center">
                  <input id="invertLogo" type="checkbox" class="h-4 w-4 text-gray-900 border-gray-300 rounded focus:ring-gray-900">
                  <label for="invertLogo" class="ml-2 block text-sm text-gray-700">Invertir colores del logo</label>
                </div>

                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label for="logoPosition" class="block text-sm font-medium text-gray-600 mb-1">Posición del logo:</label>
                    <select id="logoPosition" class="w-full p-2 border border-gray-300 rounded-md focus:ring-gray-900 focus:border-gray-900 text-sm">
                      <option value="bottomRight">Esquina inferior derecha</option>
                      <option value="center">Centro</option>
                      <option value="bottomLeft">Esquina inferior izquierda</option>
                       <option value="topRight">Esquina superior derecha</option>
                       <option value="topLeft">Esquina superior izquierda</option>
                    </select>
                  </div>
                  <div>
                    <label for="logoSize" class="block text-sm font-medium text-gray-600 mb-1">Tamaño del logo:</label>
                    <select id="logoSize" class="w-full p-2 border border-gray-300 rounded-md focus:ring-gray-900 focus:border-gray-900 text-sm">
                      <option value="8">Muy pequeño (8%)</option>
                      <option value="15">Pequeño (15%)</option>
                      <option value="25" selected>Normal (25%)</option>
                      <option value="35">Grande (35%)</option>
                    </select>
                  </div>
                </div>
             </div> <!-- Fin logoOptionsControls -->
          </div>
        </section>

        <!-- Efectos -->
        <section class="bg-white p-5 rounded-lg shadow">
          <h3 class="text-lg font-semibold text-gray-700 mb-4 border-b pb-2">4. Efectos</h3>
          <div class="space-y-2 pt-2">
            <div class="flex items-center">
              <input id="applyBW" type="checkbox" class="h-4 w-4 text-gray-900 border-gray-300 rounded focus:ring-gray-900">
              <label for="applyBW" class="ml-2 block text-sm text-gray-700">Aplicar filtro blanco y negro a todas las imágenes</label>
            </div>
             <!-- Se pueden añadir más efectos aquí -->
          </div>
        </section>
      </div>

      <!-- PANEL DERECHO -->
      <div class="space-y-6">
        <!-- Sección de Acciones -->
        <section class="bg-white p-5 rounded-lg shadow md:sticky md:top-8">
          <h3 class="text-lg font-semibold text-gray-700 mb-4 border-b pb-2">Acciones y Vista Previa</h3>

          <p class="text-sm text-gray-500 mb-4">Configura las opciones en el panel izquierdo y haz clic en "Generar Canvas" para ver el resultado.</p>

          <div class="action-buttons mt-6 flex flex-col sm:flex-row justify-center gap-3">
            <button id="generateBtn" onclick="processAndDisplayCollages()" class="inline-flex items-center justify-center px-5 py-2.5 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-gray-800 hover:bg-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-900 transition duration-150 ease-in-out">
              <svg xmlns="http://www.w3.org/2000/svg" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" id="generate-spinner" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l2-2.647z"></path></svg>
              <span id="generate-text">Generar Canvas</span>
            </button>
            <button onclick="resetCollages()" class="inline-flex items-center justify-center px-5 py-2.5 border border-gray-300 text-base font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-900 transition duration-150 ease-in-out">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 110 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
              </svg>
              Reiniciar Canvas
            </button>
          </div>

           <div id="canvasContainer" class="grid grid-cols-1 md:grid-cols-1 lg:grid-cols-1 gap-6 mt-6">
             <!-- Los canvas generados se insertarán aquí -->
              <p class="text-sm text-gray-500 text-center">Los canvas generados aparecerán aquí.</p>
           </div>
        </section>
      </div>
    </div>

  </div>

  <script>
    // URL del logo predefinido (¡Este es el único logo que se usará!)
    const FIXED_LOGO_URL = 'https://static.wixstatic.com/media/5dbf30_64f6bb0f2f814941a9f344882afbf4e8~mv2.png';
    let preloadedFixedLogo = null; // Variable para almacenar el logo fijo pre-cargado (original)
    let preloadedInvertedLogo = null; // Variable para almacenar el logo fijo pre-cargado (invertido)


    // Estado central de la aplicación
    const appState = {
        files: null,
        template: '1-single-1920', // Default template
        backgroundColor: '#ffffff', // Default background color (already has a color picker)
        imageMargin: 0, // Default margin
        addLogo: false, // Si se debe añadir el logo fijo
        invertLogo: false,
        logoPosition: 'bottomRight',
        logoSizePercent: 25, // Default size
        applyBW: false,
    };

    // Referencias a elementos DOM
    const imageInput = document.getElementById('imageInput');
    const fileInfo = document.getElementById('fileInfo');
    const templateSelect = document.getElementById('template');
    const backgroundColorInput = document.getElementById('backgroundColor'); // Color picker already exists
    const imageMarginInput = document.getElementById('imageMargin');
    const imageMarginValueSpan = document.getElementById('imageMarginValue');
    const addLogoCheckbox = document.getElementById('addLogo'); // Checkbox para añadir el logo fijo
    const invertLogoCheckbox = document.getElementById('invertLogo');
    const logoPositionSelect = document.getElementById('logoPosition');
    const logoSizeSelect = document.getElementById('logoSize');
    const applyBWCheckbox = document.getElementById('applyBW');
    const canvasContainer = document.getElementById('canvasContainer');
    const generateBtn = document.getElementById('generateBtn');
    const generateBtnSpinner = document.getElementById('generate-spinner'); // Referencia al spinner
    const generateBtnText = document.getElementById('generate-text');     // Referencia al texto del botón
    const errorMessageDiv = document.getElementById('errorMessage');
    const logoOptionsControlsDiv = document.getElementById('logoOptionsControls'); // El contenedor de las opciones de logo


    // --- Event Listeners para actualizar el estado ---

    imageInput.addEventListener('change', function() {
        appState.files = this.files;
        if (this.files && this.files.length > 0) {
            fileInfo.textContent = `${this.files.length} archivo(s) seleccionado(s).`;
        } else {
            fileInfo.textContent = 'Ningún archivo seleccionado.';
        }
    });

    // Permitir arrastrar y soltar imágenes
     document.body.addEventListener('dragover', (e) => {
         e.preventDefault(); // Prevent default to allow drop
         e.stopPropagation();
         document.body.classList.add('dragging-over'); // Optional: Add visual cue
     });
     document.body.addEventListener('dragleave', (e) => {
          e.stopPropagation();
          document.body.classList.remove('dragging-over');
     });

     document.body.addEventListener('drop', (e) => {
         e.preventDefault(); // Prevent default action (opening in new tab)
         e.stopPropagation();
         document.body.classList.remove('dragging-over');
         const files = e.dataTransfer.files;
         if (files && files.length > 0) {
             // Use the DataTransfer object directly to assign files
             const dataTransfer = new DataTransfer();
             for (let i = 0; i < files.length; i++) {
                 if (files[i].type.startsWith('image/')) {
                     dataTransfer.items.add(files[i]);
                 } else {
                     console.warn(`Ignorando archivo no imagen: ${files[i].name}`);
                 }
             }
             imageInput.files = dataTransfer.files;
             imageInput.dispatchEvent(new Event('change')); // Trigger change event
         }
     });


    templateSelect.addEventListener('change', function() { appState.template = this.value; });
    backgroundColorInput.addEventListener('input', function() { appState.backgroundColor = this.value; }); // Use input for live update
    imageMarginInput.addEventListener('input', function() { // Use input for live update of range value
        appState.imageMargin = parseInt(this.value);
        imageMarginValueSpan.textContent = `Valor: ${appState.imageMargin} px`;
    });

    // Listener para el checkbox "Añadir logo predefinido"
    addLogoCheckbox.addEventListener('change', function() {
        appState.addLogo = this.checked;
        toggleLogoOptionsControls(this.checked); // Mostrar/ocultar controles al cambiar
    });

    // --- MODIFICADO ESTE LISTENER ---
    invertLogoCheckbox.addEventListener('change', async function() { // Marcar como async
        appState.invertLogo = this.checked;

        // Si se seleccionó invertir Y el logo original está cargado
        if (this.checked && preloadedFixedLogo) {
            showInfo('Generando versión invertida del logo...');
            // Generar la imagen invertida y esperar a que cargue
            try {
                 // Crea la nueva imagen invertida (esto es síncrono)
                 const invertedImgTemp = invertImageColors(preloadedFixedLogo);

                 // Verifica si invertImageColors devolvió algo válido
                 if (invertedImgTemp && invertedImgTemp instanceof Image) {
                     // Espera a que la nueva imagen invertida cargue completamente (esto es asíncrono)
                     await new Promise((resolve, reject) => {
                         if (invertedImgTemp.complete && invertedImgTemp.naturalWidth > 0) {
                            // La imagen ya está cargada (puede pasar con Data URLs muy pequeñas o cache)
                            resolve();
                         } else {
                            // Espera el evento 'load'
                            invertedImgTemp.onload = resolve;
                            invertedImgTemp.onerror = (e) => {
                                console.error("Error loading inverted image data URL:", e);
                                reject(new Error("Failed to load inverted image data URL"));
                            };
                         }
                     });
                      // Si la promesa se resuelve, la imagen está cargada
                     preloadedInvertedLogo = invertedImgTemp; // Almacenar la versión cargada
                     console.log('Logo invertido precargado y listo.');
                     showSuccess('Versión invertida del logo lista.');

                 } else {
                      throw new Error("invertImageColors did not return a valid Image object.");
                 }


            } catch (error) {
                 console.error('Fallo la generación/carga del logo invertido:', error);
                 preloadedInvertedLogo = null; // Asegurarse de que no se use una imagen rota
                 showError('Advertencia: No se pudo generar la versión invertida del logo. La opción podría no funcionar.');
                 // Opcional: desmarcar el checkbox si falla
                 this.checked = false;
                 appState.invertLogo = false;
            }
        } else {
            // Si se desmarca invertir o el logo original no estaba cargado
            preloadedInvertedLogo = null; // Limpiar la referencia a la imagen invertida cargada
            showInfo('Opción de invertir logo desactivada.');
        }
        // Ya no generamos canvas aquí. La generación ocurre al pulsar el botón.
    });

    logoPositionSelect.addEventListener('change', function() { appState.logoPosition = this.value; });
    logoSizeSelect.addEventListener('change', function() { appState.logoSizePercent = parseInt(this.value); });
    applyBWCheckbox.addEventListener('change', function() { appState.applyBW = this.checked; });


    // --- Funciones de UI/Feedback ---

    // Muestra u oculta los controles dependientes de "Añadir logo"
    function toggleLogoOptionsControls(show) {
        if (logoOptionsControlsDiv) {
            logoOptionsControlsDiv.style.display = show ? 'block' : 'none';
        }
    }


    // Función para mostrar mensajes (error, success, info)
    function showMessage(message, type = 'error') {
      const messageEl = errorMessageDiv; // Usa la referencia global
      messageEl.textContent = message;

      // Limpiar clases anteriores y aplicar las nuevas
      messageEl.className = 'mb-4 p-3 rounded-md text-sm'; // Clases base
      messageEl.classList.add(type); // Añade clase 'error', 'success' o 'info'

      messageEl.style.display = 'block';

      // Ocultar el mensaje después de 7 segundos
      setTimeout(() => {
        messageEl.style.display = 'none';
      }, 7000);
    }

    // Funciones de helper
    function showError(message) { showMessage(message, 'error'); }
    function showSuccess(message) { showMessage(message, 'success'); }
    function showInfo(message) { showMessage(message, 'info'); }


    // --- Funciones de Carga de Imágenes ---

    // Función para pre-cargar una imagen desde una URL (¡Solo para el logo fijo!)
    async function preloadLogo(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'Anonymous'; // CRUCIAL si el logo no está en el mismo dominio (evita errores de CORS al dibujar en canvas)
            img.onload = () => resolve(img);
            img.onerror = (err) => {
                console.error("Error loading image from URL:", url, err);
                reject(err);
            };
            img.src = url;
        });
    }

    // Función para cargar múltiples imágenes desde FileList (¡Solo para las imágenes principales!)
    async function loadImages(files) {
         if (!files || files.length === 0) return [];

         showInfo(`Cargando ${files.length} imagen(es) seleccionada(s)...`);

         const loadedImages = await Promise.all(Array.from(files).map(file => {
             return new Promise(resolve => {
                 if (!file.type.startsWith('image/')) {
                      console.warn(`Skipping non-image file: ${file.name}`);
                      resolve(null); // Resolve with null for non-image files
                      return;
                 }
                 const img = new Image();
                 img.onload = () => resolve(img);
                 img.onerror = (err) => {
                      console.error('Error loading image file:', file.name, err);
                      resolve(null); // Resolve with null for failed loads
                 };
                 // Use FileReader for DataURL to avoid potential issues with URL.createObjectURL on many files
                 const reader = new FileReader();
                 reader.onload = (e) => {
                      img.src = e.target.result; // Use base64 data url
                 }
                 reader.onerror = (err) => {
                      console.error('FileReader error loading image:', file.name, err);
                      resolve(null);
                 }
                 reader.readAsDataURL(file); // Read as Base64
             });
         }));

         // Filter out null and invalid images (width/height 0)
         const validImages = loadedImages.filter(img => img !== null && img.width > 0 && img.height > 0);

         if (validImages.length < loadedImages.length) {
              showError(`Se cargaron ${validImages.length} de ${loadedImages.length} imagen(es) válidas. Ignorando archivos no válidos/con errores.`);
         } else if (validImages.length > 0) {
              showSuccess(`Todas las imágenes (${validImages.length}) cargadas correctamente.`);
         } else {
             // Case where no valid images were loaded at all
             showError('No se pudo cargar ninguna imagen válida de los archivos seleccionados.');
         }


         return validImages;
    }


    // --- Funciones de Dibujo y Efectos ---

    // Función para dibujar una imagen recortada y ajustada al contenedor
    function drawCroppedImage(ctx, img, x, y, w, h) {
        if (!img || !ctx || w <= 0 || h <= 0 || img.width <= 0 || img.height <= 0) {
             console.warn("drawCroppedImage: Invalid parameters, dimensions, or image source.", {img, x,y,w,h, imgValid: img?.width > 0 && img?.height > 0});
             // Draw a placeholder if drawing is not possible
             ctx.fillStyle = '#f0f0f0'; ctx.fillRect(x, y, w, h);
             ctx.fillStyle = '#cc3333'; // Color de texto para error
             let fontSize = Math.min(w, h) * 0.1;
             fontSize = Math.max(15, Math.min(fontSize, 40));
             ctx.font = `${fontSize}px Inter, sans-serif`;
             ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
             ctx.fillText('Draw Error', x + w/2, y + h/2);
             return;
        }

        const imgAspect = img.width / img.height;
        const boxAspect = w / h;
        let sx, sy, sWidth, sHeight;

        if (imgAspect > boxAspect) {
            // Imagen es proporcionalmente más ancha que la caja (horizontal o más ancha vertical)
            sHeight = img.height;
            sWidth = img.height * boxAspect;
            sx = (img.width - sWidth) / 2;
            sy = 0;
        } else {
            // Imagen es proporcionalmente más alta que la caja (vertical o más alta horizontal)
            sWidth = img.width;
            sHeight = img.width / boxAspect;
            sx = 0;
            sy = (img.height - sHeight) / 2;
        }

        // Ensure source dimensions are positive and within bounds
         if (sWidth <= 0 || sHeight <= 0 || sx < -1 || sy < -1 || sx + sWidth > img.width + 1 || sy + sHeight > img.height + 1) { // Add small tolerance for float errors
             console.warn("Calculated source dimensions are invalid for cropping.", {imgAspect, boxAspect, imgWidth: img.width, imgHeight: img.height, boxW: w, boxH: h, sx, sy, sWidth, sHeight});
             // Dibujar un placeholder en su lugar si el cálculo falla
             ctx.fillStyle = '#f0f0f0'; ctx.fillRect(x, y, w, h);
             ctx.fillStyle = '#cc3333'; // Color de texto para error
             let fontSize = Math.min(w, h) * 0.1;
             fontSize = Math.max(15, Math.min(fontSize, 40));
             ctx.font = `${fontSize}px Inter, sans-serif`;
             ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
             ctx.fillText('Crop Error', x + w/2, y + h/2);
             return; // Skip drawing the image
        }


        try {
           ctx.drawImage(img, sx, sy, sWidth, sHeight, x, y, w, h);
        } catch (error) {
            console.error("Error drawing image:", error, {img, sx, sy, sWidth, sHeight, x, y, w, h});
             // Dibujar un placeholder en caso de error de dibujo
             ctx.fillStyle = '#f0f0f0'; ctx.fillRect(x, y, w, h);
             ctx.fillStyle = '#cc3333'; // Color de texto para error
             let fontSize = Math.min(w, h) * 0.1;
             fontSize = Math.max(15, Math.min(fontSize, 40));
             ctx.font = `${fontSize}px Inter, sans-serif`;
             ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
             ctx.fillText('Draw Error', x + w/2, y + h/2);
        }
    }

    // Function to invert image colors (returns a new Image object from DataURL)
    // This function is synchronous but the returned Image object needs to load its src asynchronously
    function invertImageColors(imageElement) {
        if (!imageElement || imageElement.width <= 0 || imageElement.height <= 0) {
             console.error("invertImageColors: Invalid input image element.");
             return null;
        }
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = imageElement.width;
        tempCanvas.height = imageElement.height;
        const tempCtx = tempCanvas.getContext('2d');

        // Draw the original image onto the temporary canvas
        tempCtx.drawImage(imageElement, 0, 0);

        // Get the image data
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imageData.data;

        // Invert colors (R, G, B channels)
        for (let i = 0; i < data.length; i += 4) {
            data[i] = 255 - data[i];       // Red
            data[i + 1] = 255 - data[i + 1]; // Green
            data[i + 2] = 255 - data[i + 2]; // Blue
            // Alpha channel (data[i + 3]) is left unchanged
        }

        // Put the modified image data back onto the temporary canvas
        tempCtx.putImageData(imageData, 0, 0);

        // Create a new Image object from the temporary canvas Data URL
        const invertedImage = new Image();
        // Set crossOrigin for safety, though Data URLs are generally not affected by CORS.
        invertedImage.crossOrigin = 'Anonymous';
        // Convert canvas content to data URL - this starts the loading of the DataURL into the new Image object
        invertedImage.src = tempCanvas.toDataURL();

        // Return the new Image object. Its content is not immediately available; it needs to load.
        return invertedImage;
    }


    // Function to convert to black and white (aplica al canvas directamente)
    function applyBlackAndWhite(canvas) {
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      // Get the entire canvas content as ImageData
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      // Iterate through each pixel (steps of 4: R, G, B, A)
      for (let i = 0; i < data.length; i += 4) {
        // Calculate grayscale value using Luma method (more accurate perception)
        const avg = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
        // Set R, G, and B channels to the grayscale value
        data[i] = avg;     // Red
        data[i + 1] = avg; // Green
        data[i + 2] = avg; // Blue
        // Alpha channel (data[i + 3]) is unchanged
      }

      // Put the modified image data back onto the canvas
      ctx.putImageData(imageData, 0, 0);
    }


    // --- Collage Generation Logic ---

    // Creates a single canvas based on a group of images and the current state
    function createCollageCanvas(imagesForCanvas, state, canvasIndex = 0) {
        const parts = state.template.split('-'); // e.g., ["12", "3x4", "1920"]
        if (parts.length < 3) {
             console.error("Invalid template format:", state.template);
             return null;
        }
        const numImagesExpected = parseInt(parts[0]);
        const layoutType = parts[1];
        const canvasFormatSize = parseInt(parts[2]); // This is height for vertical, or potentially width/height hint for horizontal (though template names clarify)

        const canvasWidth = 1080;
        const canvasHeight = canvasFormatSize; // 1920 or 1350 based on template

        const margin = state.imageMargin; // Margin in pixels

        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // Class for CSS preview scaling
        if (canvasHeight === 1920) {
          canvas.classList.add('collage-preview');
        } else { // 1350
          canvas.classList.add('collage-preview-horizontal');
        }

        const ctx = canvas.getContext('2d');

        // 1. Draw background
        ctx.fillStyle = state.backgroundColor; // Uses the background color picker value
        ctx.fillRect(0, 0, canvas.width, canvas.height);


        // 2. Determine cell dimensions and positions (incluyendo margins)
        let cols, rows;
        switch (layoutType) {
            case 'single': cols = 1; rows = 1; break;
            case '2x2': cols = 2; rows = 2; break;
            case '3x3': cols = 3; rows = 3; break;
            case '3x4': cols = 3; rows = 4; break; // New 3x4 layout
            case 'horizontal': // 2-horizontal or 3-horizontal (vertically stacked images)
                 cols = 1;
                 rows = numImagesExpected;
                 break;
            default: console.error("Unknown layout type:", layoutType); return null;
        }

        // Calculate effective space for images after margins
        // Total space = Canvas dimension - (Margin per side + Margin between images)
        const totalHorizontalMargin = margin * (cols > 0 ? cols + 1 : 2); // (cols + 1) spaces for cols cells + 2 outer margins
        const totalVerticalMargin = margin * (rows > 0 ? rows + 1 : 2);   // (rows + 1) spaces for rows cells + 2 outer margins


        const imageSpaceWidth = canvasWidth - totalHorizontalMargin;
        const imageSpaceHeight = canvasHeight - totalVerticalMargin;

        const boxW = cols > 0 ? imageSpaceWidth / cols : imageSpaceWidth; // Image box width (handle cols=0 case defensively, though shouldn't happen with current layouts)
        const boxH = rows > 0 ? imageSpaceHeight / rows : imageSpaceHeight; // Image box height (handle rows=0 case defensively)


        // Validar calculated box dimensions
        if (boxW <= 0 || boxH <= 0) {
             console.error(`Calculated box dimensions are non-positive. W: ${boxW}, H: ${boxH}, Margin: ${margin}, Canvas: ${canvasWidth}x${canvasHeight}, Layout: ${layoutType} (${cols}x${rows})`);
             showError(`Error en el cálculo de la plantilla: El margen (${margin}px) es demasiado grande para el canvas.`);
             return null; // Indicate generation failed
        }

        // 3. Draw images or placeholders in cells
        for (let i = 0; i < numImagesExpected; i++) { // Iterate over the fixed number of cells required by the template
             const img = i < imagesForCanvas.length ? imagesForCanvas[i] : null; // Get image from the group or null

             // Calculate cell start position (initial margin + (index * (size + margin)))
             const col = i % cols;
             const row = Math.floor(i / cols);

             const x = margin + col * (boxW + margin);
             const y = margin + row * (boxH + margin);

             if (img) {
                 drawCroppedImage(ctx, img, x, y, boxW, boxH);
             } else {
                 // Draw placeholder for empty spots
                 ctx.fillStyle = state.backgroundColor === '#ffffff' ? '#f0f0f0' : adjustBrightness(state.backgroundColor, -20); // Placeholder darker than background
                 ctx.fillRect(x, y, boxW, boxH);
                 ctx.fillStyle = state.backgroundColor === '#ffffff' ? '#999999' : adjustBrightness(state.backgroundColor, -50); // Text darker still
                 let fontSize = Math.min(boxW, boxH) * 0.1;
                 fontSize = Math.max(15, Math.min(fontSize, 40)); // Clamp font size
                 ctx.font = `${fontSize}px Inter, sans-serif`; // Use a fixed font for placeholders
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 // Adjust text position slightly for middle baseline centering
                 ctx.fillText('Imagen faltante', x + boxW/2, y + boxH/2 + fontSize/4); // Added fontSize/4 adjustment
             }
        }

        // 4. Apply Black and White filter if selected
        if (state.applyBW) {
           applyBlackAndWhite(canvas); // Applies filter to all drawn content so far
        }


        // 5. Add the fixed logo if enabled and loaded
        if (state.addLogo) {
            // --- CAMBIO AQUÍ: Seleccionar la imagen del logo que ya debe estar precargada ---
            let logoToDraw = null;
            if (state.invertLogo && preloadedInvertedLogo) {
                // Si invertir está marcado Y la versión invertida está cargada, usar esa
                logoToDraw = preloadedInvertedLogo;
            } else if (!state.invertLogo && preloadedFixedLogo) {
                // Si invertir NO está marcado Y la versión original está cargada, usar esa
                logoToDraw = preloadedFixedLogo;
            }
            // --- FIN CAMBIO ---

            if (logoToDraw && logoToDraw.width > 0 && logoToDraw.height > 0) {
                // Proceed with drawing if we have a valid, loaded logo image
                const logoWidth = (canvas.width * state.logoSizePercent) / 100;
                // Calculate height to maintain aspect ratio
                const logoHeight = (logoToDraw.height * logoWidth) / logoToDraw.width;

                if (logoHeight > 0) {
                    const logoMargin = canvasWidth * 0.03; // Proportional margin (e.g., 3% of width)
                    let logoX, logoY;

                    switch (state.logoPosition) {
                        case 'bottomRight':
                            logoX = canvas.width - logoWidth - logoMargin;
                            logoY = canvas.height - logoHeight - logoMargin;
                            break;
                        case 'bottomLeft':
                            logoX = logoMargin;
                            logoY = canvas.height - logoHeight - logoMargin;
                            break;
                         case 'topRight':
                            logoX = canvas.width - logoWidth - logoMargin;
                            logoY = logoMargin;
                            break;
                         case 'topLeft':
                            logoX = logoMargin;
                            logoY = logoMargin;
                            break;
                        case 'center':
                        default:
                            logoX = (canvas.width - logoWidth) / 2;
                            logoY = (canvas.height - logoHeight) / 2;
                            break;
                    }

                    // Ensure logo is drawn within canvas boundaries
                     logoX = Math.max(0, Math.min(logoX, canvas.width - logoWidth));
                     logoY = Math.max(0, Math.min(logoY, canvas.height - logoHeight));


                    // Draw the logo image (now it's guaranteed to be a loaded image if logoToDraw is not null)
                    ctx.drawImage(logoToDraw, logoX, logoY, logoWidth, logoHeight);

                } else {
                     console.warn("Fixed logo height calculated as zero or invalid, skipping logo drawing.");
                     // showInfo("Advertencia: No se añadió el logo predefinido (problema de tamaño calculado)."); // Avoid repetitive messages
                }
            } else {
                 console.warn("Selected logo (original or inverted) not loaded or invalid dimensions, skipping logo drawing.");
                 // showInfo("Advertencia: No se añadió el logo predefinido porque no está listo o es inválido."); // Avoid repetitive messages
            }
        }


        // Create the container for this specific canvas
        const collageContainer = document.createElement('div');
        collageContainer.className = 'collage-container';

        // Add simplified info about the canvas type
        const infoSpan = document.createElement('p');
        const selectedOption = templateSelect.querySelector(`option[value="${state.template}"]`);
        const templateDesc = selectedOption ? selectedOption.textContent.split('(')[0].trim() : 'Plantilla desconocida';
        const formatType = canvasHeight === 1920 ? 'HISTORIAS' : 'PUBLICACIONES';
        infoSpan.textContent = `${templateDesc} - ${formatType}`;
        infoSpan.className = 'text-sm text-gray-500 mb-2 text-center w-full';

        collageContainer.appendChild(infoSpan);
        collageContainer.appendChild(canvas);

        // Action buttons (Download, Delete)
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'flex flex-col sm:flex-row justify-center gap-3 w-full'; // w-full to take full width

        // Create download button
        const downloadBtn = document.createElement('a');
        downloadBtn.className = 'inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-gray-800 hover:bg-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-900 transition duration-150 ease-in-out';
        downloadBtn.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
          </svg>
          Descargar Canvas ${canvasIndex + 1}
        `;
        downloadBtn.href = '#';
        downloadBtn.onclick = function(e) {
          e.preventDefault();
          // Get the canvas element to download
          const canvasToDownload = this.closest('.collage-container').querySelector('canvas');
          if (canvasToDownload) {
             const link = document.createElement('a');
             const typeLabel = canvasToDownload.height === 1920 ? 'historia' : 'publicacion';
             link.download = `canvas_${typeLabel}_${canvasIndex + 1}.jpg`;
             link.href = canvasToDownload.toDataURL('image/jpeg', 0.95); // High quality JPEG
             document.body.appendChild(link); // Append to body needed for Firefox
             link.click();
             document.body.removeChild(link); // Clean up
          } else {
             console.error("Canvas element not found for download.");
             showError("Error: No se encontró el canvas para descargar.");
          }
        };

        // Create delete button for this specific canvas
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'inline-flex items-center justify-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-900 transition duration-150 ease-in-out';
        deleteBtn.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-red-500" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553l-.724 1.447H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
          </svg>
          Eliminar
        `;
        deleteBtn.onclick = function() {
          if (confirm('¿Estás seguro que deseas eliminar este canvas?')) {
            collageContainer.remove(); // Remove the whole container div
            // If no canvas containers are left, show the placeholder text
            if(canvasContainer.childElementCount === 0) {
                canvasContainer.innerHTML = '<p class="text-sm text-gray-500 text-center">Los canvas generados aparecerán aquí.</p>';
            }
             showInfo(`Canvas ${canvasIndex + 1} eliminado.`);
          }
        };

        buttonContainer.appendChild(downloadBtn);
        buttonContainer.appendChild(deleteBtn);

        collageContainer.appendChild(buttonContainer);

        return collageContainer; // Return the container div with canvas and buttons
    }

    // Function to adjust hex color brightness (for placeholders)
    function adjustBrightness(hex, percent) {
        // Eliminar # si existe
        hex = hex.replace(/^#/, '');

        // Convertir hex a RGB
        let r = parseInt(hex.substring(0, 2), 16);
        let g = parseInt(hex.substring(2, 4), 16);
        let b = parseInt(hex.substring(4, 6), 16);

        // Ajustar brillo
        r = Math.floor(r * (100 + percent) / 100);
        g = Math.floor(g * (100 + percent) / 100);
        b = Math.floor(b * (100 + percent) / 100);

        // Asegurarse de que los valores estén entre 0 y 255
        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        b = Math.max(0, Math.min(255, b));

        // Convertir RGB de nuevo a hex
        const toHex = (c) => c.toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }


    // Main function to process and display collages
    async function processAndDisplayCollages() {
      // Disable button and show spinner
      generateBtn.disabled = true;
      generateBtnSpinner.classList.remove('hidden');
      generateBtnText.textContent = 'Generando...';
      errorMessageDiv.style.display = 'none'; // Hide previous messages

      // Validate that images are selected
      if (!appState.files || appState.files.length === 0) {
        showError('Por favor, selecciona al menos una imagen principal.');
        generateBtn.disabled = false;
        generateBtnSpinner.classList.add('hidden');
        generateBtnText.textContent = 'Generar Canvas';
        return;
      }

       // Load the main images asynchronously
      const validImages = await loadImages(appState.files);

      if (validImages.length === 0) {
           showError('No se pudo cargar ninguna de las imágenes seleccionadas. Asegúrate de que son archivos de imagen válidos.');
           generateBtn.disabled = false;
           generateBtnSpinner.classList.add('hidden');
           generateBtnText.textContent = 'Generar Canvas';
           return;
      }

      // Analyze the template value
      const parts = appState.template.split('-');
      if (parts.length < 3) {
          showError('Plantilla seleccionada inválida.');
          generateBtn.disabled = false;
          generateBtnSpinner.classList.add('hidden');
          generateBtnText.textContent = 'Generar Canvas';
          return;
      }
      const numImagesExpected = parseInt(parts[0]);
      const layoutType = parts[1];
      const canvasFormatSize = parseInt(parts[2]);

      // Check if there are enough images for at least one canvas (unless it's a single image template)
      // For single image template, we can generate one canvas per image.
      if (layoutType !== 'single' && validImages.length < numImagesExpected) {
           showError(`Para la plantilla "${appState.template}", necesitas al menos ${numImagesExpected} imágenes. Solo cargaste ${validImages.length}.`);
           generateBtn.disabled = false;
           generateBtnSpinner.classList.add('hidden');
           generateBtnText.textContent = 'Generar Canvas';
           return;
      }


      // Divide valid images into groups based on the number expected per template
       const groups = [];
       // Special case for single image template: each image gets its own canvas
       if (layoutType === 'single') {
           validImages.forEach(img => groups.push([img]));
       } else {
            // For multi-image templates, group images
           for (let i = 0; i < validImages.length; i += numImagesExpected) {
             groups.push(validImages.slice(i, i + numImagesExpected));
           }
       }


      if (groups.length === 0) {
           showError('No se pudieron formar grupos de imágenes con la plantilla seleccionada. Asegúrate de tener suficientes imágenes.');
           generateBtn.disabled = false;
           generateBtnSpinner.classList.add('hidden');
           generateBtnText.textContent = 'Generar Canvas';
           return;
       }


      // Clear previous canvas containers and the placeholder
      canvasContainer.innerHTML = '';

      // Generate and display each canvas
      groups.forEach((group, index) => {
         // Pass the pre-loaded fixed logo(s) - original and inverted - to the canvas creation function
         const collageElement = createCollageCanvas(group, appState, index); // appState contains info about which logo version to use
         if(collageElement) {
             canvasContainer.appendChild(collageElement);
         }
      });

      showSuccess(`Se han generado ${groups.length} canvas(es).`);

      // Re-enable button and hide spinner
      generateBtn.disabled = false;
      generateBtnSpinner.classList.add('hidden');
      generateBtnText.textContent = 'Generar Canvas';

      // Optional: Clear the file input after generation if you want users to re-select
      // imageInput.value = '';
      // fileInfo.textContent = 'Ningún archivo seleccionado.';
    }

    // Function to reset/clear all generated canvas elements
    function resetCollages() {
      if (confirm('¿Estás seguro que deseas eliminar todos los canvas generados?')) {
        canvasContainer.innerHTML = '<p class="text-sm text-gray-500 text-center">Los canvas generados aparecerán aquí.</p>'; // Put the placeholder back
        // Also reset relevant state variables if needed, though generating again will overwrite them.
         showInfo('Canvas limpiados.');
      }
    }

    // --- Initial Setup on Load ---
    document.addEventListener('DOMContentLoaded', () => {
         // Set initial state for logo options visibility based on checkbox state
         toggleLogoOptionsControls(addLogoCheckbox.checked);

         // Set initial range value text for margin
         imageMarginValueSpan.textContent = `Valor: ${appState.imageMargin} px`;

         // Preload the fixed logo immediately on page load
         showInfo('Cargando logo predefinido...');
         // Use async/await here also to wait for the original logo to load
         preloadLogo(FIXED_LOGO_URL).then(img => {
             preloadedFixedLogo = img; // Store the loaded original logo
             console.log('Logo original pre-cargado.');
             showSuccess('Logo predefinido cargado correctamente.');
             // No need to preload inverted here, it happens when the checkbox is clicked
         }).catch(error => {
             console.error('Fallo la pre-carga del logo fijo original:', error);
             showError('Advertencia: No se pudo cargar el logo predefinido. La función de logo podría no funcionar.', 'info');
         });
    });

  </script>
</body>
</html>